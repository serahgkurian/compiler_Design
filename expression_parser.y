/* C Declarations Section */
%{
#include <stdio.h>
#include <ctype.h>

// Prototype for the lexical analyzer
int yylex(void);

// Prototype for the error reporting function
void yyerror(const char *s);
%}

/* YACC Token and Precedence Declarations */

/* Declare the token for numbers. The 'yylval' union (by default int)
  will hold the value of the number.
*/
%token NUMBER

/*
  Declare operator precedence and associativity.
  Operators on the same line have the same precedence.
  Lines lower in the list have higher precedence.
  %left specifies left-associativity.
*/
%left '+' '-'   // Lowest precedence
%left '*' '/'   // Highest precedence

%%
/* Grammar Rules Section */

/* The start symbol 'program' can be empty or consist of multiple lines */
program:
    /* empty */
    | program line
    ;

/* A line is either a newline or an expression followed by a newline */
line:
      '\n'
    | expression '\n'   { printf("= %d\n", $1); } /* Action: Print the result */
    ;

/*
  The 'expression' rule defines the structure of a valid arithmetic expression.
  The '$$' variable represents the value of the current rule (LHS),
  while '$1', '$2', etc., represent the values of the components on the RHS.
*/
expression:
      NUMBER                 { $$ = $1; }
    | expression '+' expression  { $$ = $1 + $3; }
    | expression '-' expression  { $$ = $1 - $3; }
    | expression '*' expression  { $$ = $1 * $3; }
    | expression '/' expression  {
                                 if ($3 == 0) {
                                     yyerror("Division by zero");
                                     return 0;
                                 }
                                 $$ = $1 / $3;
                               }
    | '(' expression ')'     { $$ = $2; }
    ;

%%
/* C Code Section */

/* The main function to start the parsing process */
int main(void) {
    printf("Enter an expression, or Ctrl+D to exit.\n> ");
    yyparse();
    return 0;
}

/* The error-reporting function, called by yyparse on an error */
void yyerror(const char *s) {
    fprintf(stderr, "Error: %s\n", s);
}

/*
  A simple lexical analyzer (lexer). In a real project, this would typically
  be generated by a tool like Flex or Lex.
*/
int yylex(void) {
    int c;

    /* Skip whitespace characters */
    while ((c = getchar()) == ' ' || c == '\t');

    /* If a digit is found, it's a number */
    if (isdigit(c)) {
        ungetc(c, stdin); // Push the digit back to the input stream
        scanf("%d", &yylval); // Read the full integer value into yylval
        return NUMBER; // Return the NUMBER token
    }

    /* If at end of file, return 0 to stop parsing */
    if (c == EOF) {
        return 0;
    }

    /* For any other character (like +, -, *, /, (, ), \n), return the char itself */
    return c;
}
